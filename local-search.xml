<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>配置KVM虚拟机</title>
    <link href="/2020/08/22/%E9%85%8D%E7%BD%AEKVM%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/2020/08/22/%E9%85%8D%E7%BD%AEKVM%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>##kvm虚拟机简单布署<br>###1、    配置网络<br>####编辑配置文件<br>    vim /etc/sysconfig/network-scripts/ifcfg-ens33<br>    文件内容<br>    TYPE=Ethernet<br>    DEVICE=ens33<br>    BOOTPROTO=static<br>    NAME=ens33<br>    ONBOOT=yes<br>    IPADDR=192.168.35.1<br>    NETMASK=255.255.255.0<br>    GATEWAY=192.168.1.1<br>    DNS1=114.114.114.114<br>###2、    利用win-scp传输镜像到redhat linux<br>    确定传输机和redhatl linux在同一网段，相互联通<br>###3、搭建仓库<br>    连接cd-rom<br>    挂载cd-rom——mount /dev/sr0 /mnt/cdrom<br>    文件创建  &gt;/etc/yum.repo.d/a.repo<br>    文件内容：<br>              [redhat]<br>              name=redhat<br>             gpgcheck=0<br>             enabled=1<br>              baseurl=file:///mnt/cdrom<br>    查看仓库资源<br>              yum repolist<br>###3、    配置网络桥<br>####编辑网上配置文件<br>    vim /etc/systconfig/network-scripts/ifcfg-ens22<br>    内容：<br>        DEVICE=ens33<br>        TYPE=Ethernet<br>        ONBOOT=yes<br>        BOOTPROTO=none<br>        BRIDGE=”br0”<br>    安装网桥组件<br>        rpm -qa | grep bridge                //查看是否已安装<br>        yum install -y bridge *                //如果没有安装则执行安装操作<br>    配置网桥文件<br>    &gt; /etc/sysconfig/network-scripts/ifcfg-br0           //这个文件一般没有，需要管理员自行创建<br>    内容：<br>        DEVICE=”br0”<br>        TYPE=Bridge<br>        ONBOOT=yes<br>        BOOTPROTO=none<br>        IPADDR=192.168.1.1<br>        NETMASK=255.255.255.0<br>    查看网上配置文件和网桥配置文件<br>    vim /etc/sysconifg/network-scripts/ifcfg-ens33 /etc/sysconfig/network-scripts/ifcfg-br0 -o<br>###4、    重启网络服务<br>    systemctl restart network      //重启网上<br>       如果报错：<br>    systemctl stop NetworkManager  //关闭网络管理<br>    systemctl disable    NetworkManager.service        //移除开机启动<br>    systemctl restart network             //重启网卡<br>###5、    安装应用软件<br>    yum install -y  qemu-kvm*  virt-manager*  libvirt*          //安装qemu-kvm、virt-manager、libvirt 三个组件<br>###6、    重启虚拟服务<br>    systemctl  restart libvirtd     //重启虚拟服务<br>###7、    启动图形化界面<br>    virt-manager   //启动图形化界面<br>###8、    用图形界面完成配置虚拟机信息<br>###9、    开机 </p>]]></content>
    
    
    
    <tags>
      
      <tag>linux/KVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网卡链路聚合</title>
    <link href="/2020/08/22/%E7%BD%91%E5%8D%A1%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88/"/>
    <url>/2020/08/22/%E7%BD%91%E5%8D%A1%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h2 id="链路聚合"><a href="#链路聚合" class="headerlink" title="链路聚合"></a>链路聚合</h2><pre><code>  场景： 在数据量较大的服务器上，必须确保网络不中断的条件下，建立链路聚合，如果服务器一张网上宕机，另一张网上接替工作，而服务器的地址不变。</code></pre><h3 id="一、添加两张网上"><a href="#一、添加两张网上" class="headerlink" title="一、添加两张网上"></a>一、添加两张网上</h3><pre><code>1.在vmware workstation 中为desktop1 添加两张网卡</code></pre><h3 id="二、复制模板文件"><a href="#二、复制模板文件" class="headerlink" title="二、复制模板文件"></a>二、复制模板文件</h3><pre><code>1.寻找文件cd /usr/share/doc/teamd-1.27/example_ifcfgs/3/文件：ifcfg-eth1  ifcfg-eth2 ifcfg-team-test02.复制文件cp * /etc/sysconfig/network-scripts/          </code></pre><h3 id="三、编辑模板文件"><a href="#三、编辑模板文件" class="headerlink" title="三、编辑模板文件"></a>三、编辑模板文件</h3><pre><code>1.来到网卡配置文件目录下cd /etc/sysconfig/network-scripts/ 2.查看网卡名称ifconfig 3.将复制过来的两个模板文改为与网卡名称对应的文件mv ifcfg-eth1 ifcfg-ens33mv ifcfg-eht2 ifcfg-ens384.更改两个网卡文件vim ifcfg-ens33内容：DEVICE=&quot;ens33DEVICETYPE=&quot;TeamPort&quot;ONBOOT=&quot;yes&quot;TEAM_MASTER=&quot;team_test0&quot;vim ifcfg-ens38内容：DEVICE=&quot;ens38&quot;DEVICETYPE=&quot;TeamPort&quot;ONBOOT=&quot;yes&quot;TEAM_MASTER=&quot;team_test0&quot;4.更改team_test0文件vim ifcfg-team-test0内容：DEVICE=&quot;team_test0&quot;-----设备名DEVICETYPE=&quot;Team&quot;-----设备类型ONBOOT=&quot;yes&quot;-----开机自启BOOTPROTO=none-----手动指定IP地址NETMASK=255.255.255.0-----子网掩码IPADDR=192.168.1.234-----IP地址TEAM_CONFIG=&#39;&#123;&quot;runner&quot;: &#123;&quot;name&quot;: &quot;activebackup&quot;&#125;&#125;&#39;----策略</code></pre><h3 id="四、查看"><a href="#四、查看" class="headerlink" title="四、查看"></a>四、查看</h3><pre><code>nmcli connection show teamdctl team_test0 state    //查看两张网卡的工作状态内容：setup:  runner: activebackupports:  ens33    link watches:      link summary: up      instance[link_watch_0]:        name: ethtool        link: up        down count: 0  ens38    link watches:      link summary: up      instance[link_watch_0]:        name: ethtool        link: up        down count: 0runner:  active port: ens33                //这里可以看到活动的网卡ifconfig ens33 down              //关闭ens33，可以看到ens38会自动接替ens33的工作</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>linux/network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>交换机的工作原理</title>
    <link href="/2020/08/22/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <url>/2020/08/22/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><pre><code>交换机工作在数据链路层，以数据帧作为传输载体，依靠mac地址表作为转发依据</code></pre><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><pre><code>1、基于mac地址学习 （收到终端发来的包，记录下端口）2、收到一个广播，除源端口，所有端口转发3、基于目的mac转发4、在不同时间的不同端口收到相同的mac地址，选择最新的</code></pre><h3 id="交换机通信分析"><a href="#交换机通信分析" class="headerlink" title="交换机通信分析"></a>交换机通信分析</h3><p><img src="https://i.imgur.com/RGnGLGk.png"></p><pre><code>假设这是一个刚刚建立的网络pc1的ip:10.1.1.1 mac:54-89-98-5A-1D-F1pc2的ip:10.1.1.2mac：54-89-98-20-32-C5pc3的ip:10.1.1.3mac：54-89-98-85-0E-E2此时pc1执行pin 10.1.1.2 这条命令，由应用层产生数据，向下逐层封装，封装到数据链路层的时候因为不知道目的mac,所以以太网帧的封装不了的，此时，pc1向交换机发送一个arp requst包交换机收到arp requst包，解封装到数据链路层，交换机首先把剥开的mac地址与自己的mac地址表对比，发现自己的mac地址表里没有这个mac,所以就把这个mac保存在自己的mac地址表里面然后就会看到这个帧里面的类型，为0x0806,是一个广播包，马上把它转发到除源端口外的所有端口，两种情况：（1）pc2收到的时候解封装到网络层，更新自己的arp缓存表，记录下这个包的源ip和对应的源mac（即pc1的ip、mac）（2）然后发现这个包的目的IP是自己，它就会回一个arp reply单播包给pc1（3）而arp reply 在经过交换机的时候，交换机会解封装到数据链路层发现这个包里面的源mac自己的mac 地址表里面没有（4）然后更新自己的mac地址表，记录下这个mac 和这个mac进来的端口（5）pc1收到之后，更新自己的arp缓存表，记录下这个包的源ip和源mac(即pc2的ip、mac)（6）然后继续封装,完成之后，将ping的数据发给交换机，（7）交换机解封装，看到里面的目的mac,对照自己的mac地址表，将数据从对应的端口发出去第二种情况： (1)pc3收到交换机发过来的arp requst包之后，解封装到数据链路层，（2）更新自己的qrp缓存表，记录下这个包的源mac 和 源ip(即pc1的 mac 和 ip（3）所以在arp缓存表有效的时间内，pc3与pc1通信，是不需要发 arp requst包的)</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>internet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux下设备的挂载与使用</title>
    <link href="/2020/08/22/%E7%A3%81%E7%9B%98%E7%9A%84%E6%8C%82%E8%BD%BD%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/08/22/%E7%A3%81%E7%9B%98%E7%9A%84%E6%8C%82%E8%BD%BD%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>注：linux中的所有设备只有在经过挂载后才可以正常使用</p><h3 id="挂载的分类"><a href="#挂载的分类" class="headerlink" title="挂载的分类"></a>挂载的分类</h3><h4 id="1-临时挂载（mount-设备目录-挂载点目录）"><a href="#1-临时挂载（mount-设备目录-挂载点目录）" class="headerlink" title="1.临时挂载（mount /设备目录  /挂载点目录）"></a>1.临时挂载（mount /设备目录  /挂载点目录）</h4><h4 id="临时挂载："><a href="#临时挂载：" class="headerlink" title="临时挂载："></a>临时挂载：</h4><pre><code>需要临时性的调用存储设备，可用临时挂载,重启后自动卸载命令语法：    mount /dev/sdb    /mnt/sdb下面是一个临时挂载实例：（1）[root@localhost ~]# lsblk            //查看分区表，是否有需要挂载的设备，如果没有在虚拟机添加即可    NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT    sda             8:0    0   40G  0 disk     ├─sda1          8:1    0    1G  0 part /boot    └─sda2          8:2    0   39G  0 part        ├─rhel-root 253:0    0   37G  0 lvm  /       └─rhel-swap 253:1    0    2G  0 lvm  [SWAP]    sdb             8:16   0   20G  0 disk                 //这里找到一个没有挂载的硬盘，sdb    sr0            11:0    1  4.2G  0 rom  /mnt/cdrom（2）[root@localhost ~]# lsblk -f                 //查看分区表详细信息，是否被格式化    NAME          FSTYPE      LABEL                  UUID                                   MOUNTPOINT    sda                                                                                         ├─sda1        xfs                                7b098c20-4c39-4404-b1b6-d9e74ea76731   /boot    └─sda2        LVM2_member                        dgIvNr-jVu4-LMnp-RW5C-0az1-qH6A-C4XPuQ       ├─rhel-root xfs                                c6732474-557a-472f-b4c9-63d47334f170   /      └─rhel-swap swap                               09c4d911-ba14-4886-95b8-aa9a321f0865   [SWAP]    sdb                                          //在这里可以看到，sdb没有带文件系统                                 sr0           iso9660     RHEL-7.6 Server.x86_64 2018-10-10-18-34-13-00                 /mnt/cdrom（3）[root@localhost ~]# fdisk /dev/sdb                 //对刚刚添加的硬盘进行一个分区操作    Welcome to fdisk (util-linux 2.23.2).    Changes will remain in memory only, until you decide to write them.    Be careful before using the write command.    Device does not contain a recognized partition table    Building a new DOS disklabel with disk identifier 0xbf9f7ca3.    Command (m for help): n    //新建分区      Partition type:       p   primary (0 primary, 0 extended, 4 free)       e   extended    Select (default p):         //主分区和逻辑分区的选择，默认主分区    Using default response p    Partition number (1-4, default 1):             //分区编号，一般默认    First sector (2048-41943039, default 2048):     //起始扇区，一般默认    Using default value 2048    Last sector, +sectors or +size&#123;K,M,G&#125; (2048-41943039, default 41943039):     //结束扇区，一般+&#123;K,M,G&#125;    Using default value 41943039    Partition 1 of type Linux and of size 20 GiB is set        //创建成功    Command (m for help): w                    //保存退出（4）[root@localhost ~]# mkfs.xfs /dev/sdb1                //对刚刚创建的分区进行格式化操作    meta-data=/dev/sdb1              isize=512    agcount=4, agsize=1310656 blks             =                       sectsz=512   attr=2, projid32bit=1             =                       crc=1        finobt=0, sparse=0    data     =                       bsize=4096   blocks=5242624, imaxpct=25             =                       sunit=0      swidth=0 blks    naming   =version 2              bsize=4096   ascii-ci=0 ftype=1    log      =internal log           bsize=4096   blocks=2560, version=2             =                       sectsz=512   sunit=0 blks, lazy-count=1    realtime =none                   extsz=4096   blocks=0, rtextents=0（5）[root@localhost ~]# mkdir /mnt/sdb                //创建一个挂载点（5）[root@localhost ~]# mount /dev/sdb1 /mnt/sdb    [root@localhost ~]# lsblk    NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT    sda             8:0    0   40G  0 disk     ├─sda1          8:1    0    1G  0 part /boot    └─sda2          8:2    0   39G  0 part       ├─rhel-root 253:0    0   37G  0 lvm  /      └─rhel-swap 253:1    0    2G  0 lvm  [SWAP]    sdb             8:16   0   20G  0 disk     └─sdb1          8:17   0   20G  0 part /mnt/sdb      //这里可以看到以已经挂载到我们刚刚创建的挂载点上了    sr0            11:0    1  4.2G  0 rom  /mnt/cdrom</code></pre><h4 id="2-永久性挂载（vim-etc-fstab）"><a href="#2-永久性挂载（vim-etc-fstab）" class="headerlink" title="2.永久性挂载（vim /etc/fstab）"></a>2.永久性挂载（vim /etc/fstab）</h4><h4 id="永久性挂载："><a href="#永久性挂载：" class="headerlink" title="永久性挂载："></a>永久性挂载：</h4><pre><code>一次挂载，永久生效方法法：    写入挂载表 vim /etc/fstab    添加一行：        /设备目录        /挂载点         文件系统格式            挂载选项        硬盘开机检测 检测级别    下面是一个永久挂载实例： （1）[root@localhost ~]# lsblk                    //查看当前设备      NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT      sda             8:0    0   40G  0 disk       ├─sda1          8:1    0    1G  0 part /boot      └─sda2          8:2    0   39G  0 part         ├─rhel-root 253:0    0   37G  0 lvm  /        └─rhel-swap 253:1    0    2G  0 lvm  [SWAP]      sr0            11:0    1 1024M  0 rom   （2）添加一块硬盘，重启（在虚拟机设置里面有设置一个功能按钮，一直点到底就添加成功了） （3）[root@localhost ~]# lsblk            //可以查看一下我们添加一新硬盘为sdb         NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT      sda             8:0    0   40G  0 disk       ├─sda1          8:1    0    1G  0 part /boot      └─sda2          8:2    0   39G  0 part         ├─rhel-root 253:0    0   37G  0 lvm  /        └─rhel-swap 253:1    0    2G  0 lvm  [SWAP]      sdb             8:16   0   20G  0 disk       sr0            11:0    1 1024M  0 rom   （4）[root@localhost ~]# fdisk /dev/sdb            //我们在这里执行一个分区操作    Welcome to fdisk (util-linux 2.23.2).    Changes will remain in memory only, until you decide to write them.    Be careful before using the write command.    Device does not contain a recognized partition table    Building a new DOS disklabel with disk identifier 0x77251762.    Command (m for help): n    Partition type:       p   primary (0 primary, 0 extended, 4 free)       e   extended    Select (default p):     Using default response p    Partition number (1-4, default 1):     First sector (2048-41943039, default 2048):     Using default value 2048    Last sector, +sectors or +size&#123;K,M,G&#125; (2048-41943039, default 41943039):     Using default value 41943039    Partition 1 of type Linux and of size 20 GiB is set    Command (m for help):  （5）[root@localhost ~]# mkfs.xfs /dev/sdb1    //对刚刚的创建的分区进行一个格式化操作      meta-data=/dev/sdb1              isize=512    agcount=4, agsize=1310656 blks               =                       sectsz=512   attr=2, projid32bit=1               =                       crc=1        finobt=0, sparse=0      data     =                       bsize=4096   blocks=5242624, imaxpct=25               =                       sunit=0      swidth=0 blks      naming   =version 2              bsize=4096   ascii-ci=0 ftype=1      log      =internal log           bsize=4096   blocks=2560, version=2               =                       sectsz=512   sunit=0 blks, lazy-count=1      realtime =none                   extsz=4096   blocks=0, rtextents=0 （6）[root@localhost ~]# vim /etc/fstab      #      # /etc/fstab      # Created by anaconda on Mon Mar 18 03:41:38 2019      #      # Accessible filesystems, by reference, are maintained under &#39;/dev/disk&#39;      # See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info      #      /dev/mapper/rhel-root   /                       xfs     defaults        0 0      UUID=7b098c20-4c39-4404-b1b6-d9e74ea76731 /boot                   xfs     defaults        0 0      /dev/mapper/rhel-swap   swap                    swap    defaults        0 0添加：/dev/sdb1                 /mnt/sdb                  xfs      defaults          0 0    设备目录                     挂载点                    文件系统     选项              开机检查，检查级别 （7）[root@localhost ~]# mkdir /mnt/sdb                //刚刚忘了创建的挂载点 （8）[root@localhost ~]# mount -a                    //重读挂载表 （9）[root@localhost ~]# lsblk                        //查看挂载设备      NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT      sda             8:0    0   40G  0 disk       ├─sda1          8:1    0    1G  0 part /boot      └─sda2          8:2    0   39G  0 part         ├─rhel-root 253:0    0   37G  0 lvm  /        └─rhel-swap 253:1    0    2G  0 lvm  [SWAP]      sdb             8:16   0   20G  0 disk          └─sdb1          8:17   0   20G  0 part /mnt/sdb      //这里可以看到我们的sdb1已经挂载到/mnt/sdb上了，可以正常使用了      sr0            11:0    1 1024M  0 rom  </code></pre><h4 id="3-自动性挂载（vim-etc-fstab）"><a href="#3-自动性挂载（vim-etc-fstab）" class="headerlink" title="3.自动性挂载（vim /etc/fstab）"></a>3.自动性挂载（vim /etc/fstab）</h4><h4 id="自动挂载："><a href="#自动挂载：" class="headerlink" title="自动挂载："></a>自动挂载：</h4><pre><code>有需要时触发条件，自动挂载，不使用时自动卸载配置自动挂载流程：（1）搭建Yum仓库 [root@localhost ~]# mount /dev/sr0 /mnt/cdrom [root@localhost ~]# vim /etc/yum.repos.d/a.repo 内容：     [a]        name=a        gpgcheck=0        enabled=1        baseurl=file：///mnt/cdrom [root@localhost ~]# yum repolist Loaded plugins: langpacks, product-id, search-disabled-repos, subscription-manager This system is not registered with an entitlement server. You can use subscription-manager to register.    a                                                                                   | 4.3 kB  00:00:00         (1/2): a/group_gz                                                                   | 146 kB  00:00:00         (2/2): a/primary_db                                                                 | 4.2 MB  00:00:00         repo id                                              repo name                                       status    a                                                    a                                               5,152    repolist: 5,152    仓库搭建成功 （2）[root@localhost ~]# yum install -y autofs      //安装自动挂载的组件程序包    Loaded plugins: langpacks, product-id, search-disabled-repos, subscription-manager    This system is not registered with an entitlement server. You can use subscription-manager to register.    Resolving Dependencies    --&gt; Running transaction check    ---&gt; Package autofs.x86_64 1:5.0.7-99.el7 will be installed    --&gt; Processing Dependency: libhesiod.so.0()(64bit) for package: 1:autofs-5.0.7-99.el7.x86_64    --&gt; Running transaction check    ---&gt; Package hesiod.x86_64 0:3.2.1-3.el7 will be installed    --&gt; Finished Dependency Resolution    Dependencies Resolved    ===========================================================================================================     Package                 Arch                    Version                          Repository          Size    ===========================================================================================================    Installing:     autofs                  x86_64                  1:5.0.7-99.el7                   a                  814 k    Installing for dependencies:     hesiod                  x86_64                  3.2.1-3.el7                      a                   30 k    Transaction Summary    ===========================================================================================================    Install  1 Package (+1 Dependent package)    Total download size: 843 k    Installed size: 5.1 M    Downloading packages:    -----------------------------------------------------------------------------------------------------------    Total                                                                       18 MB/s | 843 kB  00:00:00         Running transaction check    Running transaction test    Transaction test succeeded    Running transaction      Installing : hesiod-3.2.1-3.el7.x86_64                                                               1/2       Installing : 1:autofs-5.0.7-99.el7.x86_64                                                            2/2     a/productid                                                                         | 1.6 kB  00:00:00           Verifying  : hesiod-3.2.1-3.el7.x86_64                                                               1/2       Verifying  : 1:autofs-5.0.7-99.el7.x86_64                                                            2/2     Installed:      autofs.x86_64 1:5.0.7-99.el7                                                                                 Dependency Installed:      hesiod.x86_64 0:3.2.1-3.el7                                                                                  Complete!（3）[root@localhost ~]# vim /etc/auto.master     //编辑主配置文件添加一行：        /mnt/           /etc/auto.file          --timeout=30（4）[root@localhost ~]# vim /etc/auto.file        //映射文件，默认没有，自行创建添加一行：    redhat          -fstype=xfs     :/dev/sdb1 (5)[root@localhost ~]# lsblk -f                //检查一下sdb是不是xfs格式，如果不是则需要自行格式化：mkfs.xfs /dev/sdb    NAME          FSTYPE      LABEL                  UUID                                   MOUNTPOINT    sda                                                                                         ├─sda1        xfs                                7b098c20-4c39-4404-b1b6-d9e74ea76731   /boot    └─sda2        LVM2_member                        dgIvNr-jVu4-LMnp-RW5C-0az1-qH6A-C4XPuQ       ├─rhel-root xfs                                c6732474-557a-472f-b4c9-63d47334f170   /      └─rhel-swap swap                               09c4d911-ba14-4886-95b8-aa9a321f0865   [SWAP]    sdb                                                                                         └─sdb1        xfs                                ad8d116b-6d99-441b-aca8-2ec798655d30       sr0           iso9660     RHEL-7.6 Server.x86_64 2018-10-10-18-34-13-00                 /mnt/cdrom (6)[root@localhost ~]# lsblk                //验证一下sdb1是没有挂载上去的    NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT    sda             8:0    0   40G  0 disk     ├─sda1          8:1    0    1G  0 part /boot    └─sda2          8:2    0   39G  0 part       ├─rhel-root 253:0    0   37G  0 lvm  /      └─rhel-swap 253:1    0    2G  0 lvm  [SWAP]    sdb             8:16   0   20G  0 disk     └─sdb1          8:17   0   20G  0 part                 //这里的挂载为空    sr0            11:0    1  4.2G  0 rom  /mnt/cdrom (7)[root@localhost ~]# systemctl restart autofs           //重启服务（8)[root@localhost ~]# ls /mnt/redhat                    //触发条件（9)[root@localhost ~]# lsblk                            //验证一下有没有挂载上去    NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT    sda             8:0    0   40G  0 disk     ├─sda1          8:1    0    1G  0 part /boot    └─sda2          8:2    0   39G  0 part       ├─rhel-root 253:0    0   37G  0 lvm  /      └─rhel-swap 253:1    0    2G  0 lvm  [SWAP]    sdb             8:16   0   20G  0 disk     └─sdb1          8:17   0   20G  0 part /mnt/redhat    //这里显示为挂载上去了    sr0            11:0    1  4.2G  0 rom  /mnt/cdrom(10)自动卸载,时间是我们在主配置文件里面写的&quot;--timeout=30&quot;的30s,如果闲置30s,则会自动卸载</code></pre><p>###心得体会：<br>    1.学习Linux是一件枯燥的事情,但学习linux也是一件有趣的事情<br>    2.学习linux没有统一的标准，流程，学习linux是一个不断积累的过程<br>    3.做的多了，会的也就多了，才算得上是懂了linux</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux/storage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows下设置文件共享</title>
    <link href="/2020/08/22/windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/"/>
    <url>/2020/08/22/windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h4 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h4><pre><code>1.windows平台2.由两台以上的主机 3.主机间要有物理连接（包括无线连接）</code></pre><h3 id="一、任意目录创建共享文件夹"><a href="#一、任意目录创建共享文件夹" class="headerlink" title="一、任意目录创建共享文件夹"></a>一、任意目录创建共享文件夹</h3><pre><code>1.打开此电脑————&gt;打开任意磁盘————&gt;右击————&gt;新建————&gt;文件夹2.选中文件夹————&gt;右击————&gt;属性————&gt;共享选项卡————&gt;共享————&gt;添加Everyone用户————&gt;共享</code></pre><h3 id="二、打开guest用户"><a href="#二、打开guest用户" class="headerlink" title="二、打开guest用户"></a>二、打开guest用户</h3><pre><code>1.打开控制面板————&gt;用户帐户————&gt;用户帐户————&gt;管理其他用户————&gt;选择guest用户————&gt;启用</code></pre><h3 id="三、编辑组策略编辑器"><a href="#三、编辑组策略编辑器" class="headerlink" title="三、编辑组策略编辑器"></a>三、编辑组策略编辑器</h3><pre><code>1.win+r运行————&gt;输入gpedit.msc————&gt;计算机配置————&gt;windows设置————&gt;安全设置————&gt;2.本地策略————&gt;用户权限分配————&gt;找到“拒绝从网络访问这台计算机”————&gt;删除guest用户选项</code></pre><h3 id="四、配置网络"><a href="#四、配置网络" class="headerlink" title="四、配置网络"></a>四、配置网络</h3><pre><code>要求：将提供共享文件的主机和接收文件共享的主机配置在同一个局域网内,并且保证两台主机的连通性例：    pc1 server 的ip: 10.10.128.1/24    pc2 client 的ip: 10.10.128.2/24测试方法：    在pc1使用Ping 命令测试到pc2的连通性    在pc2使用ping 命令测试到pc1的连通性</code></pre><h3 id="五、说明"><a href="#五、说明" class="headerlink" title="五、说明"></a>五、说明</h3><pre><code>1.windows 版本不同，设置步骤有细微差别2.windows xp 只要设置共享文件夹即可实现局域网共享3.windows 7 则按上面操作即可4.windows 10 按上面操作即可5.windows server 的操作步骤也是一样的</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VLAN技术的原理</title>
    <link href="/2020/08/22/VLAN%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <url>/2020/08/22/VLAN%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><pre><code>我们学习一种技术是这样一个流程：（1）为什么要有这个技术（2）这个技术的原理是什么（3）这个技术的配置是什么（4）了解这个技术的排错下面我们来了解学习一下vlan技术：</code></pre><h3 id="一、VLAN技术的背景"><a href="#一、VLAN技术的背景" class="headerlink" title="一、VLAN技术的背景"></a>一、VLAN技术的背景</h3><h4 id="1-交换机的工作原理"><a href="#1-交换机的工作原理" class="headerlink" title="1.交换机的工作原理"></a>1.交换机的工作原理</h4><pre><code> 这里我们可以从交换机讲起，我们众所周知，交换机有几个特性： 1.基于目的mac转发 2.基于目的mac学习 3.收到广播包，除了源端口外所有端口转发 4.在不同的时间收到相同的mac数据包，学习最新的那个端口 我们可以从一张图片中可以来分析一下：</code></pre><p><img src="https://i.imgur.com/MlQTJfx.png"></p><pre><code>我们可以看到，在如图的这样一个网络中，我们需要实现网络互联，假设从pc1到pc3需要通信，那么数据包在pc1封装，但是缺少dmac，所以此时我们的pc1就会发送一个apr广播包目的是全1，在数据包到达pc3之前，我途经的交换机会收到pc1的数据包，学习经过数据包的sip,并且会 执行一个动作，将sip与数据进行的端口进行一个绑定，写入到本交换机中的mac地址表中。下次再有数据包经过会真的匹配本交换机的mac地址表。mac地表更新完毕的同时，交换机的第三个特性就表现出来了，收到广播包，除了源端口外所有端口转发。所以pc1的数据包可以转发到每一个区域。    </code></pre><p><img src="https://i.imgur.com/CekxSGW.png"></p><h4 id="2-广播风暴的概念"><a href="#2-广播风暴的概念" class="headerlink" title="2.广播风暴的概念"></a>2.广播风暴的概念</h4><pre><code>由于二层设备的特点，我们的网络中会出现许多的多余的广播包，占用我们的带宽，影响我们的网络速率，但是二层设备又无法避免</code></pre><h4 id="二、VLAN技术原理"><a href="#二、VLAN技术原理" class="headerlink" title="二、VLAN技术原理"></a>二、VLAN技术原理</h4><pre><code>VLAN技术的出现是为了限制广播域，为了隔离广播风暴的大范围转发，从而从一定程度上影响整个网络的速率VLAN技术的实质是从逻辑上将物理的端口划到同一区域，有了这样的技术，我们广播包就只会在同的vlan区域转发，对于同的vlan区域，则不能转发过去。具体实现方法：（1）具体的数据包从pc端封装完成，转发致交换机，而交换机则根据数据源端口所在的vlan区域自动的在数据包的前面加上所在vlan的vid（2）交换机从端口收到一个vlan的数据包，再将数据包剥开，将vid与交换机所有的vlan id作匹配，同的vlan区域的所有端口转发。</code></pre><h3 id="三、VLAN技术的配置"><a href="#三、VLAN技术的配置" class="headerlink" title="三、VLAN技术的配置"></a>三、VLAN技术的配置</h3><pre><code>&lt;Huawei&gt;system-view Enter system view, return user view with Ctrl+Z.[Huawei][Huawei][Huawei]vlan 10[Huawei]int GigabitEthernet 0/0/1[Huawei-GigabitEthernet0/0/1]port link-type access[Huawei-GigabitEthernet0/0/1]port default vlan 10</code></pre><h3 id="四、排错"><a href="#四、排错" class="headerlink" title="四、排错"></a>四、排错</h3>]]></content>
    
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STP生成树协议</title>
    <link href="/2020/08/22/STP%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/08/22/STP%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="stp协议的背景"><a href="#stp协议的背景" class="headerlink" title="stp协议的背景"></a>stp协议的背景</h3><pre><code>为了解决单点故障的问题，提出冗余的概念，但是又产生了新的问题————环路表现形式为：（1）MAC地址表抖动（2）多帧复制（3）广播风暴</code></pre><h3 id="stp-spanning-tree-pro-生成树协议"><a href="#stp-spanning-tree-pro-生成树协议" class="headerlink" title="stp (spanning-tree pro) 生成树协议"></a>stp (spanning-tree pro) 生成树协议</h3><h4 id="先了解几个概念："><a href="#先了解几个概念：" class="headerlink" title="先了解几个概念："></a>先了解几个概念：</h4><pre><code>Brige ID: 简称BID 即网桥ID ，网桥ID代表在当前环境下的唯一一台交换机    组成：    （1）优先级，代表一个交换机的优先程度，越小越优先）    （2）MAC地址，交换机每个端口下都有一张网卡，值最小的mac，代表交换机macPort ID：简称PID 即端口ID，用来表示交换机的唯一一个端口    组成：    （1）端口号    （2）MAC地址开销：衡量一根链路上传递数据花费的代价    HUAWEI官方参考数值    10M带宽            开销 20万    100M带宽            开销 2万    1000M带宽        开销 2000</code></pre><h4 id="STP的工作原理"><a href="#STP的工作原理" class="headerlink" title="STP的工作原理"></a>STP的工作原理</h4><pre><code>第一步：选举根网桥    Root:控制整个网络的稳定    选举：        比较BID值的大小        （1）比较优先级，值越小越优先，        （2）若是优先级相同，则比较BID的另一部分，mac地址，取小的为根网桥</code></pre><p><img src="https://i.imgur.com/6573T6U.png"></p><pre><code>第二步：选举根端口（每个非根网桥只有一个）    Root port 简称RP:非根网桥接收来自根网桥的信息的端口    选举：        （1）比较到根网桥的开销，越小的越优先        （2）比较直连网桥的BID        （3）比较直连端口的PID</code></pre><p><img src="https://i.imgur.com/zBi728g.png"></p><pre><code>第三步：选取指定端口    DP：发送来自根网桥的信息，每一根链路只有一个指定端口    选举：        （1）比较到根网桥的开销，越小越优先（根网桥上所有的端口都为指定端口）        （2）比较端口所在网桥的BID</code></pre><p><img src="https://i.imgur.com/UNYJqOB.png"></p><pre><code>第四步：阻塞没有身份的所有端口</code></pre><p><img src="https://i.imgur.com/7eyanqH.png"></p><h4 id="BPDU-协议数据单元-Brige-PDU-也是数据帧的一种"><a href="#BPDU-协议数据单元-Brige-PDU-也是数据帧的一种" class="headerlink" title="BPDU:协议数据单元 Brige PDU 也是数据帧的一种"></a>BPDU:协议数据单元 Brige PDU 也是数据帧的一种</h4><pre><code>    confguration BPDU: 配置BPDU        （1）出现在stp刚启动的时候，用于网桥之间相互交换信息            （2）出现在stp稳定之后，根网桥会定时向非根网发送BPDU，宣告自己的存在    TCN topology change notifacation PDU：网络拓扑改变BPDU        （1）出现在根网桥宕机的时候</code></pre><h4 id="五种端口状态"><a href="#五种端口状态" class="headerlink" title="五种端口状态"></a>五种端口状态</h4><pre><code>disable      关闭        stp没有启动的时候blocking     阻塞        不能发送PDU,只能接收PDUlistening     监听         出现在stp刚刚启动的时候，交换机相互交换信息confguration BPDUlearning    学习        出现在stp选举的时候forwardin    转发        出现在stp已经稳定之后，可以正常转发数据</code></pre><h4 id="用于配置stp的命令"><a href="#用于配置stp的命令" class="headerlink" title="用于配置stp的命令"></a>用于配置stp的命令</h4><pre><code>    stp     enable        启动stp    stp    mode stp        将stp的模式设置为stp    stp priority 0         设置设备的优先级，0~32768  必须为4096的倍数    </code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code>（1）stp是网络协议里唯一一个遵循越小越优先的协议（2）在stp里面，网桥只有两种身份，根网桥和非根网桥（3）在stp里面的端口只有两种角色，根端口，指定端口，没有身份的端口将会被阻塞（4）根端口的作用是非根网桥用来接收来自根网桥的信息（5）指定端口的作用是发送来处根网桥的信息</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>internet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>samba服务器借权操作</title>
    <link href="/2020/08/22/samba%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%80%9F%E5%80%9F%E6%9D%83%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/08/22/samba%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%80%9F%E5%80%9F%E6%9D%83%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="一、搭建yum仓库"><a href="#一、搭建yum仓库" class="headerlink" title="一、搭建yum仓库"></a>一、搭建yum仓库</h3><pre><code> 1.挂载(提前创建挂载点)    vim /etc/fstab    添加一行内容：    /dev/sr0        /mnt/cdrom        iso9660        defaults        0 0 2.重新挂载    mount -a 3.编辑仓库文件    vim /etc/yum.repo.d/a.repo    添加内容：        [a]        name=a        gpgcheck=0        enabled=1        baseurl=file:///mnt/cdrom</code></pre><h3 id="二、安装samba程序包"><a href="#二、安装samba程序包" class="headerlink" title="二、安装samba程序包"></a>二、安装samba程序包</h3><pre><code>    yum install -y samba*</code></pre><h3 id="三、编辑samba主配置文件"><a href="#三、编辑samba主配置文件" class="headerlink" title="三、编辑samba主配置文件"></a>三、编辑samba主配置文件</h3><pre><code>    vim /etc/samba/smb.conf       添加一个区域文件：    [shared]                                        //共享名    path = /tmp/joinlabs                            //共享路径    write list = sarah                                //写入列表，这个列表的里的用户是被赋予写权限的    valid users = natasha sarah                        //允许访问的合法用户    public = no                                        //    browseable = yes</code></pre><h3 id="四、创建共享目录（如果目录存在则不用创建）"><a href="#四、创建共享目录（如果目录存在则不用创建）" class="headerlink" title="四、创建共享目录（如果目录存在则不用创建）"></a>四、创建共享目录（如果目录存在则不用创建）</h3><pre><code>    mkdir /tmp/joinlabs    chmod o+w /tmp/joinlabs                            //给予其他人写入权限</code></pre><h3 id="五、关闭防火墙-amp-SElinux"><a href="#五、关闭防火墙-amp-SElinux" class="headerlink" title="五、关闭防火墙&amp;SElinux"></a>五、关闭防火墙&amp;SElinux</h3><pre><code>    firewall-cmd --add-service=samba --permanent    //放行samba服务        firewall-cmd --reload                           //重载防火墙    systemctl status firewalld                        //查看防火墙的状态    setenforce 0                                    //关闭selinux    getenforce                                        //查看selinux的运行状态</code></pre><h3 id="六、重启服务"><a href="#六、重启服务" class="headerlink" title="六、重启服务"></a>六、重启服务</h3><pre><code>    systemctl restart smb        //重启smb服务    systemctl status smb    //查看smb服务运行状态</code></pre><h3 id="七、创建用户、配置samba访问密码"><a href="#七、创建用户、配置samba访问密码" class="headerlink" title="七、创建用户、配置samba访问密码"></a>七、创建用户、配置samba访问密码</h3><pre><code>    useradd natasha                                 //创建natasha用户，上面列表里没有写入权限但是有访问权限的用户    useradd sarah                                    //创建sarah用户，上面列表里有写入权限的用户，稍后我们将以natasha的身份向sarah借写入权限    smbpasswd natasha -a                            //配置natasha用户的samba服务的访问密码    smbpasswd sarah -a                                //配置sarah用户的samba服务访问密码</code></pre><h3 id="八、登录到samba服务器"><a href="#八、登录到samba服务器" class="headerlink" title="八、登录到samba服务器"></a>八、登录到samba服务器</h3><pre><code>    smbclient //192.168.2.10/shared -U natasha%redhat    //登录samba服务器</code></pre><h3 id="九、挂载到本地"><a href="#九、挂载到本地" class="headerlink" title="九、挂载到本地"></a>九、挂载到本地</h3><pre><code> 1.安装cifs组件    yum install -y cifs* 2.写入挂载表    vim /etc/fstab    添加一行内容：    //192.168.2.10/shared        /mnt/shared            cifs    defaults,user=natasha,password=redhat,multiuser,sec=ntlmssp    0 0 3.重读挂载表    mount -a 4.查看设备挂载情况 (这个时候可以看到有一条网络挂载的记录    df -h    //192.168.2.10/shared   17G  1.2G   16G   7% /mnt/shared    mount                                                //查询挂载选项是否生效    //192.168.2.10/shared on /mnt/shared type cifs (rw,relatime,vers=default,sec=ntlmssp,cache=strict,multiuser,domain=,uid=0,noforceuid,gid=0,noforcegid,addr=192.168.2.10,file_mode=0755,dir_mode=0755,soft,nounix,serverino,mapposix,noperm,rsize=1048576,wsize=1048576,echo_interval=60,actimeo=1)        ！！可以看到我们写的挂载选项已经生效</code></pre><h3 id="十、测试权限"><a href="#十、测试权限" class="headerlink" title="十、测试权限"></a>十、测试权限</h3><pre><code> 1.切换到natasha用户（即没有写入权限的用户）    su - natasha     cd /mnt/shared    mkdir 1    mkdir: cannot create directory ‘1’: Permission denied     提示权限拒绝， 2.切换到sarah用户（即有写入权限的用户）     su - sarah     cd /mnt/shared    mkdir 1    mkdir: cannot create directory ‘1’: Permission denied 3.原因：    我们执行的操作是在挂载点上创建目录，而我们的挂载表里是以natasha用户挂载的，所以在挂载点上执行操作是受到挂载用户权限限制的，下面让我们来借权： 4.借权    su - natasha         或    su - sarah      cifscreds  add  192.168.2.10  -u sarah    Password: 输入密码    mkdir 1    ll    发现在natasha用户下文件创建成功，则证明借权成功</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>linux/server</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>samba服务器基本搭建</title>
    <link href="/2020/08/22/samba%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/08/22/samba%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="一、准备工作："><a href="#一、准备工作：" class="headerlink" title="一、准备工作："></a>一、准备工作：</h3><pre><code>1.搭建一个本地Yum仓库（1）挂载    vim /etc/fstab     添加一行：        /dev/sr0                /mnt/cdrom              iso9660 defaults        0 0    （2）编辑仓库文件    vim /etc/yum.repo.d/a.repo    内容：    [a]                    //仓库名    name=a              //描述    gpgcheck=0            //校验    enabled=1            //是否启用    baseurl=file:///mnt/cdrom        //url(3)添加挂载点    mkdir /mnt/cdrom(4)重读挂载表    mount -a    mount: /dev/sr0 is write-protected, mounting read-only(5)列出仓库yum repolist            //列出仓库资源Loaded plugins: langpacks, product-id, search-disabled-repos, subscription-managerThis system is not registered with an entitlement server. You can use subscription-manager to register.a                                                                                   | 4.3 kB  00:00:00     (1/2): a/group_gz                                                                   | 146 kB  00:00:00     (2/2): a/primary_db                                                                 | 4.2 MB  00:00:00     repo id                                              repo name                                       statusa                                                    a                                               5,152repolist: 5,152</code></pre><h3 id="二、配置samba服务"><a href="#二、配置samba服务" class="headerlink" title="二、配置samba服务"></a>二、配置samba服务</h3><pre><code>(1)安装samba组件yum install -y samba(2)编辑主配置文件vim /etc/samba/smb.conf内容：[redhat]comment = hello wordpath = /tmp/sharebrowseable = Yespublic  = Yeswriteable  = Yes(3)创建共享文件夹mkdir /tmp/share(4)配置samba服务登录用户密码(前提是alex真实存在)smbpasswd -a alex提示如下:New SMB password:Retype new SMB password:Added user alex.(5)关闭防火墙    systemctl stop firewalld.service (6)关闭selinuxsetenforce 0samba服务配置完成</code></pre><h3 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h3><h4 id="windows平台下测试："><a href="#windows平台下测试：" class="headerlink" title="windows平台下测试："></a>windows平台下测试：</h4><pre><code>（1）打“此电脑”，在地址栏输入\\IP地址（2）输入登录用户和密码（3）右击，“映射网络驱动器”（4）在此电脑下可以看到</code></pre><h4 id="linux平台下测试"><a href="#linux平台下测试" class="headerlink" title="linux平台下测试"></a>linux平台下测试</h4><pre><code>（1）安装组件    yum install -y cifs-utils（2）创建挂载目录    mkdir /mnt/smb（3）挂载    mount -t cifs  //10.10.128.200/tmp/share /mnt/smb/ -o username=alex（6）查看    lsblk</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>linux/server</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSI开放系统互联模型</title>
    <link href="/2020/08/22/OSI%E5%BC%80%E6%94%BE%E7%B3%BB%E7%BB%9F%E4%BA%92%E8%81%94%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/08/22/OSI%E5%BC%80%E6%94%BE%E7%B3%BB%E7%BB%9F%E4%BA%92%E8%81%94%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><pre><code>网络技术的基础：OSI （开放系统互联模型）也是所有网络的理论依据</code></pre><h5 id="三个名词："><a href="#三个名词：" class="headerlink" title="三个名词："></a>三个名词：</h5><pre><code>IOS:互联网操作系统 ISO:国际标准化组织OSI:开放系统互联模型</code></pre><h5 id="四个点："><a href="#四个点：" class="headerlink" title="四个点："></a>四个点：</h5><pre><code>（1）为什么有这个技术（2）原理（3）配置（4）排错</code></pre><h3 id="二、OSI七层模型出现的原因"><a href="#二、OSI七层模型出现的原因" class="headerlink" title="二、OSI七层模型出现的原因"></a>二、OSI七层模型出现的原因</h3><pre><code>（1）以前的网络是一个整体（2）各个厂商之间不兼容（3）不利于开发和排错</code></pre><h3 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h3><pre><code>按照功能将网络分为七层，每一层都有各自的功能，相互独立，却又相互联系![](https://i.imgur.com/bsITheX.png)</code></pre><h3 id="物理层的功能"><a href="#物理层的功能" class="headerlink" title="物理层的功能"></a>物理层的功能</h3><pre><code>（1）定义：    介质类型          有线：双绞线、同轴电缆、光纤        无线：无线电、微波    线缆标准：            568B：橙白/橙/绿白/蓝/蓝白/绿/棕白/棕        568A：绿白/绿/橙白/蓝/蓝白/橙/棕白/棕    传输距离：        双绞线100m    信号类型        电信号        光信号（2）物理层的设备    Hub（集线器）：信号的放大和复制    特性:        所有设备在同一冲突域        所有设备在同一广播域        所有设备共享相同带宽（连接在hub上的设备是分时间片的使用带宽，达到名义上的相同带宽）    CSMA/CD（载波监听多点接入/碰撞检测）机制        CSMA/CD机制出现的原因：随着接入的设备越多，冲突也就越大        CSMA/CD机制提出：一个时间内只能有一台设备使用带宽，设备在使用链路时，要先对链路进行监听，如果有人在传输数据，则需要等待        如果没有人在传输数据，则不需要等待，在链路上发布jam信号，传输数据        如果别的设备此时需要传输数据，而监听到链路上的jam信号        则不会立即传输数据，而是等待当前设备传输完成后，链路上没有jam信号了，再进行传输            </code></pre><h3 id="数据链路层的功能"><a href="#数据链路层的功能" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h3><pre><code>（1）定义    源和目的物理地址（MAC）    帧校验序列FCS（2）数据帧的标准     (1) 以太网                点到多点               一般用于交换机     (2) PPP                 点到点            一根链路上只有两台设备     (3) FR帧中继标准            点到多点            指定链路，要提前预设好线路 ，不用mac,不用ip,用FR标识号（3）以太网帧的标准    IEEE 802.1 (没人用)    ETHERNET II  (点到多点链路)    帧组成：    FLAG    SMAC    DMAC    TYPE    DATA    FCS    FLAG:标志，标识一个帧的开始    SMAC:源mac地址    DMAC:目的mac地址    TYPE:类型，表明这个帧承载的上层协议            0X0800        上层协议为IP                    0X0806        上层协议为ARP    DATA:数据部分    FCS: 帧校验（4）数据链路层的设备    交换机    特性：        每一个端口都是一个冲突域        广播包向所有端口转发（5）极域软件的通信工作原理    利用广播的原理，由教师端的pc只需要向该网段的广播地址发送自己的屏幕图形，所以该网段内的所有主机都能收到老师端的屏幕数据    因为所有的主机，在开机状态下，都会自动监听本机所在网段的广播地址，从而实现投屏的效果</code></pre><h3 id="网络层的功能"><a href="#网络层的功能" class="headerlink" title="网络层的功能"></a>网络层的功能</h3><pre><code>（1）定义    逻辑地址（IP地址）    路径选择（2）网络层的设备    路由器    功能：            广播控制（阻隔广播风景）        逻辑寻址        路径选择        提供wan连接        流量控制    特性：        每一个接口都是一个广播域</code></pre><h3 id="传输层的功能"><a href="#传输层的功能" class="headerlink" title="传输层的功能"></a>传输层的功能</h3><pre><code>（1）定义    两种传输方式（2）两种传输方式</code></pre><p><img src="https://i.imgur.com/l82AMji.png"></p><pre><code>（3）常用端口号</code></pre><p><img src="https://i.imgur.com/NJIkJeB.png" alt="avatar"></p><pre><code>（4）TCP三次握手机制</code></pre><p><img src="https://i.imgur.com/gzEl523.png" alt="avatar"></p><pre><code>（5）TCP简单确认机制</code></pre><p><img src="https://i.imgur.com/63sBETY.png" alt="avatar"></p><pre><code>（6）数据的封装与解封装</code></pre><p><img src="https://i.imgur.com/uG7hqBJ.png" alt="avatar"></p>]]></content>
    
    
    
    <tags>
      
      <tag>internet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NTP服务器简单配置</title>
    <link href="/2020/08/22/NTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/08/22/NTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h4 id="系统环境：rhel-7-6"><a href="#系统环境：rhel-7-6" class="headerlink" title="系统环境：rhel 7.6"></a>系统环境：rhel 7.6</h4><h3 id="简单思路："><a href="#简单思路：" class="headerlink" title="简单思路："></a>简单思路：</h3><pre><code>1.服务器地址：10.10.128.1  客户端地址：10.10.128.2-32.准备工作：（1）关闭防火墙（2）关闭selinux（3）搭建yum仓库3.配置服务器4.配置客户端5.测试    </code></pre><h3 id="一、设置网络"><a href="#一、设置网络" class="headerlink" title="一、设置网络"></a>一、设置网络</h3><pre><code>    set server:    ifconfig ens33 10.10.128.1/24 up    set client: ifconfig ens33 10.10.128.2/24 up    </code></pre><h3 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h3><pre><code>    1.设置防火墙        systemctl stop firewalld.service      //关闭防火墙        systemctl status firewalld.service     //查看防火墙状态    2.关闭selinux        setenforce 0    3.搭建Yum仓库        vim /etc/yum.repo.d/a.repo        内容：        [a]        name=a        gpgcheck=0        enabled=1        baseurl=file:///mnt/cdrom</code></pre><h3 id="三、配置服务器"><a href="#三、配置服务器" class="headerlink" title="三、配置服务器"></a>三、配置服务器</h3><pre><code>    1.安装NTP组件        yum install -y ntp     2.修改主配置文件</code></pre><h3 id="四、配置客户端"><a href="#四、配置客户端" class="headerlink" title="四、配置客户端"></a>四、配置客户端</h3><h3 id="五、测试"><a href="#五、测试" class="headerlink" title="五、测试"></a>五、测试</h3>]]></content>
    
    
    
    <tags>
      
      <tag>linux/server</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NFS服务器的基本搭建</title>
    <link href="/2020/08/22/NFS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/08/22/NFS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="环境"><a href="#环境" class="headerlink" title="环境:"></a>环境:</h3><pre><code>redhat 7.6 serverredhat 7.6 clientvmware workstation</code></pre><h3 id="一、搭建yum仓库"><a href="#一、搭建yum仓库" class="headerlink" title="一、搭建yum仓库"></a>一、搭建yum仓库</h3><pre><code>1.挂载本地光盘 (1)创建挂载点 mkdir /mnt/cdrom (2)编写挂载表  vim /etc/fstab 内容：  /dev/sr0     /mnt/cdrom        iso9660        defaults    0 0 (3)刷新挂载表  mount -a (4)查看是否挂载成功  lsblk2.创建仓库文件  vim /etc/yum.repo.d/a.repo    //&quot;a.repo&quot;为仓库文件，需要手动创建 内容：    [a]    name=a    gpgcheck=0    enabled=1    baseurl=file:///mnt/cdrom保存退出wq2.查看仓库文件是否生效    yum repolist</code></pre><h3 id="二、安装nfs组件"><a href="#二、安装nfs组件" class="headerlink" title="二、安装nfs组件"></a>二、安装nfs组件</h3><pre><code>yum install -y nfs*</code></pre><h3 id="三、编写主配置文件"><a href="#三、编写主配置文件" class="headerlink" title="三、编写主配置文件"></a>三、编写主配置文件</h3><pre><code>vim /etc/exports内容：/tmp/redhat     192.168.8.0/24(rw,sync)        //主配置文件分为两列，第一列为共享的资源（目录），第二列为可以接受共享的用户后面括号是（共享选项）保存退出wq</code></pre><h3 id="四、重启服务"><a href="#四、重启服务" class="headerlink" title="四、重启服务"></a>四、重启服务</h3><pre><code>systemctl restart nfs</code></pre><h3 id="五、测试"><a href="#五、测试" class="headerlink" title="五、测试"></a>五、测试</h3><pre><code>切换到client系统下：showmount -e 192.168.8.200            //查看目标路径的共享资源mount -t nfs     192.168.8.200:/tmp/redhat /mnt/nfs    //将目标用户共享的资源/tmp/redhat挂载到本地的 /mnt/nfs下</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>linux/network storage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nextcloud个人云盘完整过程</title>
    <link href="/2020/08/22/Nextcloud%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%9B%98%E6%90%AD%E5%BB%BA%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B/"/>
    <url>/2020/08/22/Nextcloud%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%9B%98%E6%90%AD%E5%BB%BA%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>##Nextcloud私有云盘搭建教程 ##<br>###环境：###<br>    操作系统：centos_7.6 x86-64<br>    mariadb:5.5.56-Mariadb<br>    php:php 7.0.31<br>    nextcloud:nextcloud-13.0.5<br>    确保机器正常连网<br>    ……<br>1.安装过程</p><pre><code>安装Nginx安装 epel源    yum instlal -y epel-release    yum instlal -y nginx启动nginx    systemctl start nginx    systemctl enable nginx</code></pre><p>2.安装mariadb</p><pre><code>更换国内的yum源    cd /etc/yum.repo.d/    wget -O Centos-Base.repo http://mirrors.aliyum.com/repo/Centos-7.repo    yum clean all &amp;&amp; yum makecache如果是最小化安装的操作系统，是没有wget工具的，所发需要安装一下wget    yum install -y wget安装mariadb     yum install -y mariadb-server mariadb    systemctl start mariadb    systemctl enable mariadb设置数据库密码    echo &#39;skip-grant-tables&#39;&gt;&gt;/etc/my.cnf    systemctl restart maridb    mysql -u root     MariaDB [(none)]&gt; use mysql;    MariaDB [mysql]&gt; select user, password, host from user;    MariaDB [mysql]&gt; update user set password=password(&#39;这里输入自己的密码&#39;) where User=&quot;root&quot; and Host=&quot;localhost&quot;;    MariaDB [mysql]&gt; flush privileges;    MariaDB [mysql]&gt; exit注释掉/etc/my.cnf最后一行，重启数据库    systemctl restart mariadb    systemctl enable mariadb</code></pre><p>3.安装PHP</p><pre><code>安装php及依赖插件    yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm    yum install http://rpms.remirepo.net/enterprise/remi-release-7.rpm安装php环境    yum install yum-utils    yum-config-manager --enable remi-php70   [Install PHP 7.0]    yum-config-manager --enable remi-php71   [Install PHP 7.1]    yum-config-manager --enable remi-php72   [Install PHP 7.2]安装扩展    yum install php php-mcrypt php-cli php-gd php-curl php-mysql php-ldap php-zip php-fileinfo \    php-devel php-pear php-gd php-opcache php-cli php-pdo php-process php-pecl-apcu php-mcrypt \    php-mysql php-fpm php-pecl-memcached php-common php-xml php-mbstring php-pecl-igbinary-devel    所有的组件都要安装哦，太长可以先复制到记事本，然后再复制到xshell或者mobaxter等远程工具。制作签名和SSL证书    mkdir /etc/nginx/cert/    cd /etc/nginx/cert/    openssl rep -new -x509 -days 365 -nodes -out /etc/nginx/cert/nextcloud.crt -keyout /etc/nginx/cert/nextcloud.key赋权限    chmod 600 /etc/nginx/cert/*    chmod 700 /etc/nginx/cert/</code></pre><p>4.下载Nextcloud</p><pre><code>下载13.0.2版本    cd /opt/    wget https://download.nextcloud.com/server/releases/nextcloud-13.0.5.zip    unzip nextcloud-13.0.5.zip    cd /usr/share/nginx/html    rm -rf *    cp -R /op/nextcloud/* .    chown -R nginx:nginx /usr/share/nginx/html</code></pre><p>5.配置php和nginx</p><pre><code>    配置PHP    vim /etc/php-fpm.d/www.conf    -------------------------------------    user = nginx                                   //将用户和组都改为nginx    group = nginx    listen = 127.0.0.1:9000    env[HOSTNAME] = $HOSTNAME                     //将以下几行，去掉注释    env[PATH] = /usr/local/bin:/usr/bin:/bin    env[TMP] = /tmp    env[TMPDIR] = /tmp    env[TEMP] = /tmp    -------------------------------------    # 创建session文件夹    mkdir -p /var/lib/php/session    chown nginx:nginx -R /var/lib/php/session/    配置Nginx    cd /etc/nginx/conf.d/    vim nextcloud.conf    -------------------------------------upstream php-handler &#123;server 127.0.0.1:9000;#server unix:/var/run/php5-fpm.sock;&#125;server &#123;listen 80;    server_name localhost;   # enforce httpsrewrite ^(.*)$ https://$host$1 permanent;&#125;server &#123;listen 443 ssl;server_name localhost;ssl_certificate /etc/nginx/cert/nextcloud.crt;ssl_certificate_key /etc/nginx/cert/nextcloud.key;# Add headers to serve security related headers# Before enabling Strict-Transport-Security headers please read into this# topic first.add_header Strict-Transport-Security &quot;max-age=15768000;includeSubDomains; preload;&quot;;add_header X-Content-Type-Options nosniff;add_header X-Frame-Options &quot;SAMEORIGIN&quot;;add_header X-XSS-Protection &quot;1; mode=block&quot;;add_header X-Robots-Tag none;add_header X-Download-Options noopen;add_header X-Permitted-Cross-Domain-Policies none;# Path to the root of your installationroot /usr/share/nginx/html/;       //这个地址要注意，是主页的保存地址，也就是解压nextcloud的地址location = /robots.txt &#123;    allow all;    log_not_found off;    access_log off;&#125;# The following 2 rules are only needed for the user_webfinger app.# Uncomment it if you&#39;re planning to use this app.#rewrite ^/.well-known/host-meta /public.php?service=host-meta last;#rewrite ^/.well-known/host-meta.json /public.php?service=host-meta-json# last;location = /.well-known/carddav &#123;  return 301 $scheme://$host/remote.php/dav;&#125;location = /.well-known/caldav &#123;  return 301 $scheme://$host/remote.php/dav;&#125;# set max upload sizeclient_max_body_size 10240M;    # 上传文件最大限制，php.ini中也要修改，最后优化时会提及。fastcgi_buffers 64 4K;# Disable gzip to avoid the removal of the ETag headergzip on;gzip_vary on;gzip_comp_level 4;gzip_min_length 256;gzip_proxied expired no-cache no-store private no_last_modified no_etag auth;gzip_types application/atom+xml application/javascript application/json application/ld+json application/manifest+json application/rss+xml application/vnd.geo+json application/vnd.ms-fontobject application/x-font-ttf application/x-web-app-manifest+json application/xhtml+xml application/xml font/opentype image/bmp image/svg+xml image/x-icon text/cache-manifest text/css text/plain text/vcard text/vnd.rim.location.xloc text/vtt text/x-component text/x-cross-domain-policy;# Uncomment if your server is build with the ngx_pagespeed module# This module is currently not supported.#pagespeed off;error_page 403 /core/templates/403.php;error_page 404 /core/templates/404.php;location / &#123;    rewrite ^ /index.php$uri;&#125;location ~ ^/(?:build|tests|config|lib|3rdparty|templates|data)/ &#123;    deny all;&#125;location ~ ^/(?:\.|autotest|occ|issue|indie|db_|console) &#123;    deny all;&#125;location ~ ^/(?:index|remote|public|cron|core/ajax/update|status|ocs/v[12]|updater/.+|ocs-provider/.+|core/templates/40[34])\.php(?:$|/) &#123;    include fastcgi_params;    fastcgi_split_path_info ^(.+\.php)(/.*)$;    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;    fastcgi_param PATH_INFO $fastcgi_path_info;    fastcgi_param HTTPS on;    #Avoid sending the security headers twice    fastcgi_param modHeadersAvailable true;    fastcgi_param front_controller_active true;    fastcgi_pass php-handler;    fastcgi_intercept_errors on;    fastcgi_request_buffering off;&#125;location ~ ^/(?:updater|ocs-provider)(?:$|/) &#123;    try_files $uri/ =404;    index index.php;&#125;# Adding the cache control header for js and css files# Make sure it is BELOW the PHP blocklocation ~* \.(?:css|js)$ &#123;    try_files $uri /index.php$uri$is_args$args;    add_header Cache-Control &quot;public, max-age=7200&quot;;    # Add headers to serve security related headers (It is intended to    # have those duplicated to the ones above)    # Before enabling Strict-Transport-Security headers please read into    # this topic first.    add_header Strict-Transport-Security &quot;max-age=15768000;includeSubDomains; preload;&quot;;    add_header X-Content-Type-Options nosniff;    add_header X-Frame-Options &quot;SAMEORIGIN&quot;;    add_header X-XSS-Protection &quot;1; mode=block&quot;;    add_header X-Robots-Tag none;    add_header X-Download-Options noopen;    add_header X-Permitted-Cross-Domain-Policies none;    # Optional: Don&#39;t log access to assets    access_log off;&#125;location ~* \.(?:svg|gif|png|html|ttf|woff|ico|jpg|jpeg)$ &#123;    try_files $uri /index.php$uri$is_args$args;    # Optional: Don&#39;t log access to other assets    access_log off;&#125;&#125;注释掉默认配置文件里的80端口模块vim /etc/nginx/nginx.conf#server &#123;#    listen       80 default_server;#    listen       [::]:80 default_server;#    server_name  _;#    root         /usr/share/nginx/html;#    # Load configuration files for the default server block.#    include /etc/nginx/default.d/*.conf;#    location / &#123;#    &#125;#    error_page 404 /404.html;#        location = /40x.html &#123;#    &#125;#    error_page 500 502 503 504 /50x.html;#        location = /50x.html &#123;#    &#125;#&#125;</code></pre><p>6.关掉SELINUX与防为墙<br>    setenforce 0<br>    sed -i “s/=enforcing/=disabled/g” /etc/selinux/config</p><p>7.web访问&amp;&amp;安装<br>    默认80，打开浏览器，输入你的服务器ip<br>    一切顺利的话成功进入登陆页面（不顺利应该是php扩展的原因，再调试）：</p><p>8.性能调整</p><pre><code>admin用户登陆后页面上方会有警告提示，根据提示进行更改就好...</code></pre><p>9.PHP<br>    vim /etc/php.ini<br>    [PHP]<br>    # 添加如下配置<br>    opcache.enable=1<br>    opcache.enable_cli=1<br>    opcache.interned_strings_buffer=8<br>    opcache.max_accelerated_files=10000<br>    opcache.memory_consumption=128<br>    opcache.save_comments=1<br>    opcache.revalidate_freq=1</p><pre><code>upload_max_filesize = 10240M  #上传大小限制</code></pre><p>10.缓存</p><pre><code>yum install -y memcachevim /etc/sysconfig/memcachedPORT=&quot;11211&quot;USER=&quot;memcached&quot;MAXCONN=&quot;1024&quot;CACHESIZE=&quot;2048&quot;OPTIONS=&quot;&quot;</code></pre><p>11.nextcloud添加memcache缓存配置</p><pre><code>vim /usr/share/nginx/html/config/config.php&#39;memcache.local&#39; =&gt; &#39;\OC\Memcache\APCu&#39;,  &#39;memcache.distributed&#39; =&gt; &#39;\OC\Memcache\Memcached&#39;,  &#39;memcached_servers&#39; =&gt; array(   array(&#39;localhost&#39;, 11211),    ),</code></pre><p>12.重启<br>    systemctl restart memcached<br>    systemctl enable memcached</p><p>说明：本文完全是参照大佬的文章，边做边写，边总结，里面也有一些小提示，不喜勿喷。原文地址：<a href="https://www.jianshu.com/p/497a1f11e968">https://www.jianshu.com/p/497a1f11e968</a> </p>]]></content>
    
    
    
    <tags>
      
      <tag>linux/server</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LINUX用户管理</title>
    <link href="/2020/08/22/linux%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%E7%9A%84%E7%AE%A1%E7%90%86/"/>
    <url>/2020/08/22/linux%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%E7%9A%84%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h3><pre><code>redhat7.6vmware workstation 15</code></pre><h3 id="用户是什么？？"><a href="#用户是什么？？" class="headerlink" title="用户是什么？？"></a>用户是什么？？</h3><p>用户是使用机器的操作员，即对机器进行操作的角色</p><h3 id="一、用户的分类"><a href="#一、用户的分类" class="headerlink" title="一、用户的分类"></a>一、用户的分类</h3><p>  1.普通用户</p><pre><code>登录用户，权限有限，只能执行“/bin”下的命令，统一由root用户进行管理，分配</code></pre><p>  2.超级管理员用户</p><pre><code>在系统里面具有最高权限，uid=0,gid=0，可以执行所有操作</code></pre><p>  3.系统用户</p><pre><code>主要服务于应用，维护系统运行，不能登录常见的系统用户：bin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologinuucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologingames:x:12:100:games:/usr/games:/sbin/nologingopher:x:13:30:gopher:/var/gopher:/sbin/nologinftp:x:14:50:FTP User:/var/ftp:/sbin/nologinnobody:x:99:99:Nobody:/:/sbin/nologin</code></pre><p> 4.系统用户的功能</p><pre><code>Linux系统的大部分权限和安全的管理依赖于对于文件权限（读、写、执行）的管理，而用户是能够获取系统资源的权限的集合，文件权限的拥有者为用户；当应用需要访问/操作/拥有系统的资源时，Linux就通过用户来控制/实现，这些用户就是系统用户。</code></pre><p> 5.用户的管理与操作</p><pre><code>useradd+[option] +user: ————用户的创建参数详解：    -c: 用户描述    -d: 指定用户家目录    -g: 指定用户的用户所属组，用gid表示，前提是gid必须存在    -s：指定shell 一般为： /bin/bash   不可登录设置为：／sbin/nologin      -G: 指定用户所属附加组    ………………        想要了解更多参数请输入：man useraddusermod+[option]+user:————用户帐户修改参数详解：    -c：　修改用户帐号的备注文字。    -d：　修改用户家目录。    -e: 　修改帐号的有效期限。    -f: 　修改在密码过期后多少天即关闭该帐号。    -g: 　修改用户所属的群组。    -G: 　修改用户所属的附加群组。    -l: 　修改用户帐号名称。    -L:      使密码无效。    -s:   修改用户登入后所使用的shell。    -u: 　修改用户ID。    -U:      解除密码锁定。    ………………        想要了解更多参数请输入：man usermoduserdel +[option]+ user: ————删除用户参数详解：    -r:  使用者目录下的档案一并删除，其他位置的档案也一并找出删除 注意：删除用户不带参数-r删除用户时，并不会删除用户家目录下的文档和所属用户组，所以不能再次创建同名的用户，和用户组    ………………        想要了解更多参数请输入：man userdel</code></pre><p>6.为用户配置密码</p><pre><code>方法一：    passwd + user    在提示下分别再次输入密码方法二:    echo redhat | passwd --stdin sanfu    配置成成功有提示,将sanfur的密码配置为redhat方法三：    echo sanfu redhat| chpasswd     配置成功没有提示，将sanfu的密码配置为redhat</code></pre><h3 id="二、用户组"><a href="#二、用户组" class="headerlink" title="二、用户组"></a>二、用户组</h3><h3 id="用户组是什么？？"><a href="#用户组是什么？？" class="headerlink" title="用户组是什么？？"></a>用户组是什么？？</h3><pre><code>linux系统以group来管理用户，用户和组的关系多对多，一人用户可以加入多个组，一个组也可以加入多个用户</code></pre><h3 id="组的分类"><a href="#组的分类" class="headerlink" title="组的分类"></a>组的分类</h3><p>   1.主组</p><pre><code>用户置默认的组，用户gid所标识的组，即用户创建时自动生成的组</code></pre><p>  2.附属组</p><pre><code>用户的附加组</code></pre><p>  3.组的管理与操作</p><pre><code>groupadd+[option]+group  ————创建用户组参数详解:    -g: 指定gid    -r:    创建系统工作组，系统工作组的id不得小于500    -o: 允许用不唯一的id号添加工作组groupmod+[option]+group    ————修改用户组参数详解：    -g:更改用户组的gid    -n:更改用户组的名称groupdel+[option]+group ————用户组的删除参数详解：    无</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>linux/user</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux交换分区管理</title>
    <link href="/2020/08/22/linux%E4%B8%8B%E9%85%8D%E7%BD%AE%E4%BA%A4%E6%8D%A2%E5%88%86%E5%8C%BA/"/>
    <url>/2020/08/22/linux%E4%B8%8B%E9%85%8D%E7%BD%AE%E4%BA%A4%E6%8D%A2%E5%88%86%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h3><pre><code>vmware workstation 15redhat 7.6</code></pre><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><pre><code>类似于windows的虚拟内存，当系统内存不够时，拿出一部分的硬盘空间来当内存使用，从而解决内存不足的情况，它的功能就是在内存不够的情况下，操作系统先把内存中暂时不用的数据，存到硬盘的交换空间，腾出内存来让别的程序运行，和Windows的虚拟内存（pagefile.sys）的作用是一样的</code></pre><h3 id="制作交换分区的方法"><a href="#制作交换分区的方法" class="headerlink" title="制作交换分区的方法"></a>制作交换分区的方法</h3><hr><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><pre><code>用空文件来做交换分区1.查看现在交换分区大小[root@localhost ~]# free -h                      total        used        free      shared  buff/cache   availableMem:           1.8G        508M        879M         10M        431M        1.1GSwap:          2.0G          0B        2.0G2. 创建一个空文件，做交换分区要用的[root@localhost ~]# dd if=/dev/zero of=/tmp/swap.file bs=1G count=1  1+0 records in1+0 records out1073741824 bytes (1.1 GB) copied, 13.1283 s, 81.8 MB/s3. 建立swap的文件系统[root@localhost ~]# mkswap /tmp/swap.file                             Setting up swapspace version 1, size = 1048572 KiBno label, UUID=72a276cb-280f-4af8-9702-e728ab16ab654.启用swap文件[root@localhost ~]# swapon /tmp/swap.file                            swapon: /tmp/swap.file: insecure permissions 0644, 0600 suggested.5.挂载[root@localhost ~]# vim /etc/fstab添加一行内容：/tmp/swap.file          swap                    swap    defaults        0 0退出保存6.查看[root@localhost ~]# free -h              total        used        free      shared  buff/cache   availableMem:           1.8G        503M        1.0G         10M        250M        1.1GSwap:          3.0G        264K        3.0G结论：可以看到交换分区多了1G，扩展分区成功，如果不需要，卸载即可</code></pre><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><pre><code>用分区来做交换分区1.查看已知交换分区大小[root@localhost ~]# free -h              total        used        free      shared  buff/cache   availableMem:           1.8G        502M        1.0G         10M        264M        1.1GSwap:          3.0G        264K        3.0G2.创建一个分区来做交换分区[root@localhost ~]# fdisk /dev/sdb                        Welcome to fdisk (util-linux 2.23.2).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Command (m for help):  n                这里输入n新建分区Partition type:           p   primary (1 primary, 0 extended, 3 free)   e   extendedSelect (default p):   p                  这里输入p新建主分区，输入e新建逻辑分区Partition number (2-4, default 2):       这里是分区编号，默认即可First sector (4196352-41943039, default 4196352):   起始扇区，如果没有特殊要求，默认即可Using default value 4196352Last sector, +sectors or +size&#123;K,M,G&#125; (4196352-41943039, default 41943039):      结束扇区,一般+&#123;K,M,G&#125;Partition 2 of type Linux and of size 2 GiB is set      我们这里分2G Command (m for help): w                                    按w保存[root@localhost ~]# lsblk                                可以看到我们新创建的分区已经成功了，如果没有看到，用partparobe更新分区表NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTsda             8:0    0   40G  0 disk ├─sda1          8:1    0    1G  0 part /boot└─sda2          8:2    0   39G  0 part   ├─rhel-root 253:0    0   37G  0 lvm  /  └─rhel-swap 253:1    0    2G  0 lvm  [SWAP]sdb             8:16   0   20G  0 disk ├─sdb1          8:17   0    2G  0 part /mnt/sdb└─sdb2          8:18   0    2G  0 part sr0            11:0    1 1024M  0 rom  3.建立swap文件系统[root@localhost ~]# mkswap /dev/sdb2Setting up swapspace version 1, size = 2097148 KiBno label, UUID=5ee02ff1-b01b-4560-9544-b44bc1f620d94.激活swap功能[root@localhost ~]# swapon /dev/sdb25.挂载[root@localhost ~]# vim /etc/fstab添加一行内容：/dev/sdb2               swap                    swap    defaults        0 0按w保存退出[root@localhost ~]# lsblk                可以查看分区sdb2挂载的位置NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTsda             8:0    0   40G  0 disk ├─sda1          8:1    0    1G  0 part /boot└─sda2          8:2    0   39G  0 part   ├─rhel-root 253:0    0   37G  0 lvm  /  └─rhel-swap 253:1    0    2G  0 lvm  [SWAP]sdb             8:16   0   20G  0 disk ├─sdb1          8:17   0    2G  0 part /mnt/sdb└─sdb2          8:18   0    2G  0 part [SWAP]sr0            11:0    1 1024M  0 rom  6.查看[root@localhost ~]# free -h              total        used        free      shared  buff/cache   availableMem:           1.8G        504M        990M         10M        323M        1.1GSwap:          5.0G        264K        5.0G这里可以看到交换分区扩展成功</code></pre><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><pre><code>1.交换分区的步骤有三步，建立文件系统——&gt;激活交换分区功能——&gt;挂载使用2.使用的命令有：    lsblk: 查看挂载表    free -h : 查看交换分区大小    mkswap : 建立交换分区的文件格式    swapon : 激活交换分区功能    swapon -s : 查看交换分区详细信息</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>linux/storage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RHEL/CENTOS磁盘配额</title>
    <link href="/2020/08/22/linux%E4%B8%8B%E7%A3%81%E7%9B%98%E9%85%8D%E9%A2%9Dext4&amp;xfs/"/>
    <url>/2020/08/22/linux%E4%B8%8B%E7%A3%81%E7%9B%98%E9%85%8D%E9%A2%9Dext4&amp;xfs/</url>
    
    <content type="html"><![CDATA[<h3 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h3><pre><code>vmware workstation 15redhat 7.6/centos 7.6</code></pre><h3 id="使用情景："><a href="#使用情景：" class="headerlink" title="使用情景："></a>使用情景：</h3><pre><code>配额是面向用户进行的磁盘空间管理工作，其目的是为了限制用户过多的使用磁盘资源，造成浪费，降低空间利用率</code></pre><h3 id="一、ext4文件系统的配额方法"><a href="#一、ext4文件系统的配额方法" class="headerlink" title="一、ext4文件系统的配额方法"></a>一、ext4文件系统的配额方法</h3><pre><code>1.添加硬盘    在vmware workstation 的图形化界面中用鼠标添加一块新硬盘    重启，系统重新读盘 2.分区     fdisk /dev/sdb    /*我这是第一次添加一个硬盘，所以编号为sdb*/    Command (m for help): /*输入操作选项 新建分区输入n*/    Command action       a   toggle a bootable flag   设定硬盘启动区       b   edit bsd disklabel       c   toggle the dos compatibility flag       d   delete a partition        删除一个分区       g   create a new empty GPT partition table       G   create an IRIX (SGI) partition table       l   list known partition types  列出已知的分区类型，不常用的分区类型可以在这里找到       m   print this menu                                显示所有的列表       n   add a new partition                            新建一个分区       o   create a new empty DOS partition table   创建一个新的dos分区表       p   print the partition table               输出分区表       q   quit without saving changes      退出不保存       s   create a new empty Sun disklabel       t   change a partition&#39;s system id   更改分区类型       u   change display/entry units       v   verify the partition table               w   write table to disk and exit 写入分区表，保存操作       x   extra functionality (experts only)        Partition type:           p   primary (1 primary, 0 extended, 3 free)        主分区           e   extended                                        扩展分区、        Select (default p):                                 这里输入p        Partition number (1-4, default 1):                     这里是分区编号，默认即可        First sector (2048-41943039, default 2048):         起始扇区，没有特殊要求默认即可        Using default value 2048                            从2048扇区开始        Last sector, +sectors or +size&#123;K,M,G&#125; (2048-41943039, default 41943039):     结束扇区，可以+&#123;K,M,G&#125;        Partition 1 of type Linux and of size 2 GiB is set    分区1，类型为linux主分区，大小是2G        分区创建成功！！3.格式化     注意：所有的分区，逻辑卷，阵列，如果不进行格式化都不能进行挂载使用    mkfs.[type]+目录    例：mkfs.xfs /dev/sdb/sdb14.挂载    注意：所有的分区，逻辑卷，阵列，如果不进行挂载就不能进行使用     临时挂载：        mount  [目录] [挂载目录]        例：mount /dev/sdb/sdb1 /mnt    永久性挂载：        vim /etc/fstab            内容：        添加一行：/dev/sdb/sdb1      /mnt/        iso9660        xfs        defaults  0 05.更改权限     chmod 777 /mnt/            权限给到最大方便测试6.文件创建与扫描     quotacheck /mnt/7.激活配额点     quotaon  /mnt/8.对用户进行配额操作     edquota alex     编辑内容：        Disk quotas for user alex (uid 1001):          Filesystem                   blocks       soft       hard     inodes     soft     hard          /dev/sdb1                       352        300        400          1        0        0     参数详解：        blocks     块大小限制        inodes    文件个数限制        soft    软限制            hard    硬限制9.验证    dd if=/dev/zero of=/mnt/1.test    bs=1k  count=401    提示：        [alex@localhost mnt]$ dd if=/dev/zero of=/mnt/1.test bs=1k count=401  测试写入401k        sdb1: warning, user block quota exceeded.        sdb1: write failed, user block limit reached.        dd: error writing ‘/mnt/1.test’: Disk quota exceeded    错误，超限,证明硬限制生效        401+0 records in        400+0 records out        409600 bytes (410 kB) copied, 0.00162328 s, 252 MB/s</code></pre><h3 id="二、xfs文件系统的磁盘配额"><a href="#二、xfs文件系统的磁盘配额" class="headerlink" title="二、xfs文件系统的磁盘配额"></a>二、xfs文件系统的磁盘配额</h3><pre><code> 1.添加硬盘     在vmware workstation    图形化界面中用鼠标添加一块新硬盘 2.分区    对新添加的硬盘进行分区    fdisk /dev/sdb   选择新添加的硬盘进行分区操作    Command (m for help):             这里输入进行分区的操作，我们输入n,添加一个新分区     Partition type:                    分区类型       p   primary (0 primary, 0 extended, 4 free) 主分区        e   extended                                     扩展分区    Select (default p):             这里我们输入p,默认输入p    Partition number (1-4, default 1):这里是分区编号，默认为1，最多只能创建4个主分区    First sector (2048-41943039, default 2048):       这里是起始扇区，如果没有特殊要求默认即可Using default value 2048    Last sector, +sectors or +size&#123;K,M,G&#125; (2048-41943039, default 41943039): 这里是结束扇区，可+&#123;K,M,G&#125;，根据需要输入    Partition 1 of type Linux and of size 2 GiB is set     分区1，类型为linux主分区，大小为2G    Command (m for help): p      输出所有的分区    Command (m for help): w   最后输入w保存退出 3.格式化    注意：所有的设备，分区，阵列，逻辑卷，只有在格式化之后才可以被挂载    mkfs.xfs /dev/sdb1    lsblk -f            可查看是否格式化成功 4.挂载    注意:所有的设备，分区，阵列，逻辑卷，只有在挂载后才能正常使用    临时挂载：        mount /dev/sdb1  /mnt/sdb   将dev下的设备sdb1挂载到/mnt/sdb    永久挂载        vim /etc/fstab   编辑挂载表文件        内容:        添加一行:             /dev/sdb1  /mnt/sdb  xfs   defaults,usrquota      0 0        mount -a 重读分区表        mount 查看挂载是否成功        /dev/sdb1 on /mnt/sdb type xfs (rw,relatime,seclabel,attr2,inode64,usrquota)   确保挂载选项有usrquota  5.更改权限    chmod 777 /mnt/sdb  将权限开到最大，方便测试，在实际环境中，只要保证配额用户有写入权限  6.设置配额    xfs_quota -x -c &quot;limit bsoft=300k bhard=400k alex&quot; /mnt/sdb    注意：这里配置成功是没有提示的，需要用户自行测试  7.测试    切换用户alex    su - alex    测试1写入425k     dd if=/dev/zero of=/mnt/sdb/1.txt bs=1k count=425    dd: error writing ‘/mnt/sdb/1.txt’: Disk quota exceeded    401+0 records in    400+0 records out    409600 bytes (410 kB) copied, 0.00254558 s, 161 MB/s    最终成功写入400k，证明硬限制400K生效    total 400K    -rw-rw-r--. 1 alex alex 400K Jun 12 07:16 1.txt    测试2写入350k    如果已经做了测试1，要把测试1生成的1.txt删除        rm -rf 1.txt    dd if=/dev/zero of=/mnt/sdb/2.txt bs=1k count=350   测试写入350k    350+0 records in    350+0 records out    358400 bytes (358 kB) copied, 0.00110362 s, 325 MB/s    ll -h     /mnt/total 352K    -rw-rw-r--. 1 alex alex 350K Jun 12 07:23 2.txt   成功写入350k，但是没有报警，软限制没有生效</code></pre><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><pre><code>1.两种文件系统的配额方法不一样2.ext4文件系统的步骤为： 准备：分区，格式化，挂载 文件创建扫描 激活配额挂载点 编辑配额文件 写入测试3.xfs文件系统的步骤为： 准备：分区，格式化，挂载 设置配额 写入文件测试4.分区，阵列，逻辑卷都可以做配额5.针对用户做配额，在挂载选项里写defaults,usrquota,用mount查看挂载usrquota功能是否成功6.针对组做配额也可以，步骤大同小异7.学习linux，一定要有自学能力，如果你认为自己的自学能力很强，那请你再加强，如果你认为自学能力不强，那就赶紧培养，linux老师，是教不完的，是学不完的，学无止境</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>linux/storage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ISCS服务器基本搭建</title>
    <link href="/2020/08/22/ISCSI%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/08/22/ISCSI%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h3><pre><code>rhel 7.6 vmware workstation 15</code></pre><h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><pre><code>1.配置静态IP地址 （1）方法一：    ifconfig ens33 10.10.128.100     //我这里用的是10.10.128.0网段 （2）方法二：    vim /etc/sysconfig/network-scripts/ifcfg-ens33    内容：        TYPE=Ethernet        BOOTPROTO=static        DEFROUTE=yes        NAME=ens33        DEVICE=ens33        ONBOOT=yes        IPADDR=10.10.128.100        NETMASK=255.255.255.02.搭建本地yum仓库 （1）挂载光盘    vim /etc/fstab    内容：    添加一行：    /dev/sr0           /mnt/cdrom           iso9660 defaults        0 0 （2）创建挂载目录    mkdir /mnt/cdrom  （3）重读挂载表    mount -a （4）编辑仓库文件    vim /etc/yum.repos.d/a.repo        //a.repo为仓库名，     内容：    [a]    name=a    gpgcheck=0    enabled=1    baseurl=file:///mnt/cdrom （5）列出仓库资源    yum repolist        //这里可以看到仓库是否创建成功，如果不成功就要排错3.安装组件 （1）安装iscsi组件    yum install -y targetcli （2）查看是否安装成功    rpm -qa targetcli4.配置iscsi （1）添加一块新硬盘作共享盘        //在vmware station中添加 （2）重启    reboot （3）配置target    targetcli    进入这样的界面：    targetcli shell version 2.1.fb46    Copyright 2011-2013 by Datera, Inc and others.    For help on commands, type &#39;help&#39;.    /&gt;  （4）创建block关联    /&gt; backstores/block create zlf.server /dev/sdb                //这条命令是创建共享名，关联刚刚添加的新硬盘sdb    Created block storage object zlf.server using /dev/sdb.        //这是提示创建成功 （5）查看    ls    结果：    /&gt; ls    o- / ................................................................................................................. [...]      o- backstores ...................................................................................................... [...]      | o- block .......................................................................................... [Storage Objects: 1]      | | o- zlf.server ............................................................ [/dev/sdb (20.0GiB) write-thru deactivated]        //这里可以看到刚刚添加的关联      | |   o- alua ........................................................................................... [ALUA Groups: 1]      | |     o- default_tg_pt_gp ............................................................... [ALUA state: Active/optimized]      | o- fileio ......................................................................................... [Storage Objects: 0]      | o- pscsi .......................................................................................... [Storage Objects: 0]      | o- ramdisk ........................................................................................ [Storage Objects: 0]      o- iscsi .................................................................................................... [Targets: 0]      o- loopback ................................................................................................. [Targets: 0]    /&gt;  （6）创建target    /&gt; iscsi/ create  iqn.2019-07.com.example:server            //在iscsi下创建 iqn.2019-07.com.example:server     Created target iqn.2019-07.com.example:server.    Created TPG 1.    Global pref auto_add_default_portal=true    Created default portal listening on all IPs (0.0.0.0), port 3260.        //创建成功 （7）创建访问控制    /&gt; iscsi/iqn.2019-07.com.example:server/tpg1/acls create iqn.2019-07.com.example:server                //这条命令是创建访问控制    Created Node ACL for iqn.2019-07.com.example:server                                                    //提示成功 （8）删除默认的允许访问列表    /&gt; iscsi/iqn.2019-07.com.example:server/tpg1/portals/ delete 0.0.0.0 3260                             //删除0.0.0.0 3260 默认的访问列表和端口    Deleted network portal 0.0.0.0:3260 （9）创建新的访问列表    /&gt; iscsi/iqn.2019-07.com.example:server/tpg1/portals  create 10.10.128.0 3260                        //开放给10.10.128.0这个网段访问    Using default IP port 3260    Created network portal 10.10.128.0:3260. （10）查看    /&gt; ls    o- / ................................................................................................................. [...]      o- backstores ...................................................................................................... [...]      | o- block .......................................................................................... [Storage Objects: 1]      | | o- zlf.server ............................................................ [/dev/sdb (20.0GiB) write-thru deactivated]        //看到我们关联的硬盘      | |   o- alua ........................................................................................... [ALUA Groups: 1]      | |     o- default_tg_pt_gp ............................................................... [ALUA state: Active/optimized]      | o- fileio ......................................................................................... [Storage Objects: 0]      | o- pscsi .......................................................................................... [Storage Objects: 0]      | o- ramdisk ........................................................................................ [Storage Objects: 0]      o- iscsi .................................................................................................... [Targets: 1]      | o- iqn.2019-07.com.example:server ............................................................................ [TPGs: 1]        //看到我们创建的target      |   o- tpg1 ....................................................................................... [no-gen-acls, no-auth]      |     o- acls .................................................................................................. [ACLs: 1]      |     | o- iqn.2019-07.com.example:server ............................................................... [Mapped LUNs: 0]        //允许访问的target      |     o- luns .................................................................................................. [LUNs: 0]      |     o- portals ............................................................................................ [Portals: 1]      |       o- 10.10.128.0:3260 ......................................................................................... [OK]        //写的访问地址      o- loopback ................................................................................................. [Targets: 0]    /&gt;  （11）保存、退出    /&gt; saveconfig    Configuration saved to /etc/target/saveconfig.json    /&gt; exit    Global pref auto_save_on_exit=true    Last 10 configs saved in /etc/target/backup/.    Configuration saved to /etc/target/saveconfig.json    [root@localhost ~]#                         //看到这里就退出成功了5.直接用windows访问 （1）打开iscsi发起程序 （2）更改配置名为 iqn.2019-07.com.example:server  （3）输入目标ip ：10.10.128.100 （4）快速连接6.配置client端</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>linux/storage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DNS主/从服务器基本配置</title>
    <link href="/2020/08/22/DNS%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/08/22/DNS%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h3><pre><code>redhat 7.6 *2 vmwware workstation 15pro</code></pre><h2 id="一、搭建DNS主服务器"><a href="#一、搭建DNS主服务器" class="headerlink" title="一、搭建DNS主服务器"></a>一、搭建DNS主服务器</h2><h3 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h3><pre><code>（1)开启一台虚拟机（2)配置网络、静态IP</code></pre><h3 id="1-搭建yum仓库"><a href="#1-搭建yum仓库" class="headerlink" title="1. 搭建yum仓库"></a>1. 搭建yum仓库</h3><pre><code>（1).挂载光盘    vim /etc/fstab    添加一行：    /dev/sr0        /mnt/cdrom        iso9660        defaults    0 0（2).配置yum仓库文件    vim /etc/yum.repo.d/a.repo    内容：    [a]    name=a    gpgcheck=0    enabled=1    baseurl=file:///mnt/cdrom    （3).检测仓库    yum repolist    以下为配置成功的界面</code></pre><hr><pre><code>    repo id         repo name                                status    !a                 a                                      5,152</code></pre><hr><h3 id="2-安装程序包"><a href="#2-安装程序包" class="headerlink" title="2.安装程序包"></a>2.安装程序包</h3><pre><code>yum install -y bind*</code></pre><h3 id="3-编辑主配置文件"><a href="#3-编辑主配置文件" class="headerlink" title="3.编辑主配置文件"></a>3.编辑主配置文件</h3><pre><code>vim /etc/named.conf主配置文件如下：options &#123;    listen-on port 53 &#123; 192.168.35.1; &#125;;    //修改为监听的端口和主机    listen-on-v6 port 53 &#123; ::1; &#125;;    directory       &quot;/var/named&quot;;    dump-file       &quot;/var/named/data/cache_dump.db&quot;;    statistics-file &quot;/var/named/data/named_stats.txt&quot;;    memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;;    recursing-file  &quot;/var/named/data/named.recursing&quot;;    secroots-file   &quot;/var/named/data/named.secroots&quot;;    allow-query     &#123; any; &#125;;            //配置访问控制    allow-transfer &#123; 192.168.35.2; &#125;;    //设置为从服务器的IP&#125;;logging &#123;        channel default_debug &#123;                file &quot;data/named.run&quot;;                severity dynamic;        &#125;;&#125;;</code></pre><hr><pre><code>zone&quot;zlf.com&quot; IN &#123;                    //此处为zlf.com的正向解析文件        type master;                //类型为master        file &quot;zlf.zone&quot;;            //解析文件存储在/var/named/目录下&#125;;</code></pre><hr><hr><pre><code>zone &quot;35.168.192.in-addr.arpa&quot; IN &#123;        //此处为反向解析文件        type master;                    //类型为master        file &quot;rezlf.zone&quot;;                //反向解析文件存储在/var/named/目录下&#125;;</code></pre><hr><h3 id="4-创建正向解析文件"><a href="#4-创建正向解析文件" class="headerlink" title="4.创建正向解析文件"></a>4.创建正向解析文件</h3><pre><code>cd /var/namedcp named.localhost  zlf.zone    //将模板文件复制为正向解析文件,这个正向解析文件名对应主配置文件里的正向解析文件名，如果文件名打错，则会无法解析vim /var/named.zlf.zone内容：$TTL 1D    @       IN SOA  www.zlf.com.     www.zlf.com. (                                            0       ; serial                                            1D      ; refresh                                            1H      ; retry                                            1W      ; expire                                            3H )    ; minimum             NS      www.zlf.com.    www     A       192.168.35.1</code></pre><h3 id="5-创建反向解析文件"><a href="#5-创建反向解析文件" class="headerlink" title="5.创建反向解析文件"></a>5.创建反向解析文件</h3><pre><code>cd /var/namedcp named.localhost rezlf.zone内容：$TTL 1D@       IN SOA  www.zlf.com. www.zlf.com. (                                        0       ; serial                                        1D      ; refresh                                        1H      ; retry                                        1W      ; expire                                        3H )    ; minimum        NS      www.zlf.com.1       PTR     www.zlf.com.</code></pre><h3 id="6-重启服务"><a href="#6-重启服务" class="headerlink" title="6.重启服务"></a>6.重启服务</h3><pre><code>systemctl restart named</code></pre><h3 id="7-测试"><a href="#7-测试" class="headerlink" title="7.测试"></a>7.测试</h3><pre><code>nslookup www.zlf.comdig -t xafr zlf.com           </code></pre><h2 id="一、搭建DNS从服务器"><a href="#一、搭建DNS从服务器" class="headerlink" title="一、搭建DNS从服务器"></a>一、搭建DNS从服务器</h2><h3 id="准备工件"><a href="#准备工件" class="headerlink" title="准备工件"></a>准备工件</h3><pre><code>（1)开启另外一台服务器    （2)iP地址配置为和主服务器同一网段</code></pre><h3 id="1-搭建Yum仓库"><a href="#1-搭建Yum仓库" class="headerlink" title="1.搭建Yum仓库"></a>1.搭建Yum仓库</h3><pre><code>（1).挂载光盘    vim /etc/fstab    添加一行：    /dev/sr0        /mnt/cdrom        iso9660        defaults    0 0（2).配置yum仓库文件    vim /etc/yum.repo.d/a.repo    内容：    [a]    name=a    gpgcheck=0    enabled=1    baseurl=file:///mnt/cdrom    （3).检测仓库    yum repolist    以下为配置成功的界面</code></pre><hr><pre><code>    repo id         repo name                                status    !a                 a                                      5,152</code></pre><hr><h3 id="2-安装软件包"><a href="#2-安装软件包" class="headerlink" title="2.安装软件包"></a>2.安装软件包</h3><pre><code>yum install -y bind*</code></pre><h3 id="3-编辑主配置文件-1"><a href="#3-编辑主配置文件-1" class="headerlink" title="3.编辑主配置文件"></a>3.编辑主配置文件</h3><pre><code>vim /etc/    内容：options &#123;    listen-on port 53 &#123; 192.168.35.2; &#125;;        //设置监听端口    listen-on-v6 port 53 &#123; ::1; &#125;;    directory       &quot;/var/named&quot;;    dump-file       &quot;/var/named/data/cache_dump.db&quot;;    statistics-file &quot;/var/named/data/named_stats.txt&quot;;    memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;;    recursing-file  &quot;/var/named/data/named.recursing&quot;;    secroots-file   &quot;/var/named/data/named.secroots&quot;;    allow-query     &#123; any; &#125;;                    //所有有可访问，这里可以是网段也可以是IP&#125;;logging &#123;        channel default_debug &#123;                file &quot;data/named.run&quot;;                severity dynamic;        &#125;;&#125;;zone &quot;zlf.com&quot; IN &#123;                        //正向解析文件        type slave;                        //类型为slave        file &quot;slaves/zlf.zone&quot;;                    masters &#123;192.168.35.1; &#125;;        //定义一个masters 为主服务器的ip地址&#125;;zone &quot;35.168.192.in-addr.arpa&quot; IN &#123;        //反向解析文件        type slave;                        //类型为slave        file &quot;slaves/rezlf.zone&quot;;                masters &#123; 192.168.35.1; &#125;;        //定义一个masters 为主服务器的ip地址&#125;;</code></pre><h3 id="4-配置网络"><a href="#4-配置网络" class="headerlink" title="4.配置网络"></a>4.配置网络</h3><pre><code>（1)开启一台虚拟机    vim /etc/sysconfig/network-scripts/ifcfg-ens33    内容：    TYPE=Ethernet    BOOTPROTO=static    DEFROUTE=yes    NAME=ens33    DEVICE=ens33    ONBOOT=yes    IPADDR=192.168.35.2    NETMASK=255.255.255.0    DNS1=192.168.35.2     //将DNS设置为从服务器的地址，稍后直观的可以看出从服务器是否正常工作（2)重启网络    systemctl restart network</code></pre><h3 id="5-重启DNS服务"><a href="#5-重启DNS服务" class="headerlink" title="5.重启DNS服务"></a>5.重启DNS服务</h3><pre><code>    systemctl restart named</code></pre><h3 id="6-测试"><a href="#6-测试" class="headerlink" title="6.测试"></a>6.测试</h3><pre><code>nslookup www.zlf.comdig -t arxf zlf.com</code></pre><h3 id="结语："><a href="#结语：" class="headerlink" title="结语："></a>结语：</h3><pre><code>做到这里主从dns服务器就已经搭建完成了，这里有几个要注意的地方主服务器：    1、需要修改一个文件，创建两个文件,分别为/etc/named.conf  /var/named/正向解析文件  /var/named/反向解析文件    2、在optons中要添加一行        allow-transfer= &#123; 192.168.35.1&#125;;    3、从服务器:    1、只需要修改一个主配置文件     2、需要和主服务器设置为同一网段    3、type  =slave    4、masters = &#123;192.168.35.1&#125;;     5、file = &quot;slaves/zlf.zone &quot;          </code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>linux/server</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DNS服务器基本搭建</title>
    <link href="/2020/08/22/DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/08/22/DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="一、配置服务器网络"><a href="#一、配置服务器网络" class="headerlink" title="一、配置服务器网络"></a>一、配置服务器网络</h3><pre><code>注意：DNS服务器要有必须要有一个静态的ip地址（1）编写网卡主配置文件    vim /etc/sysconfig/network-scripts/ifcfg-ens33 内容：    TYPE=Ethernet    BOOTPROTO=static    DEFROUTE=yes    IPV4_FAILURE_FATAL=no    NAME=ens33    UUID=7fac3a10-de6b-42c6-9175-cef32343c69b    DEVICE=ens33    ONBOOT=yes    IPADDR=192.168.35.1    NETMASK=255.255.255.0    DNS1=192.168.35.1            //指定为服务器（2）重启网络服务        systemctl restart network   //重启网络服务（3）查看网卡配置文件是否生效    ifconfig         //查看网络配置</code></pre><h3 id="二、搭建yum仓库"><a href="#二、搭建yum仓库" class="headerlink" title="二、搭建yum仓库"></a>二、搭建yum仓库</h3><pre><code>（1）挂载光盘    vim /etc/fstab内容：添加一行：    /dev/sr0        /mnt/cdrom        iso9660        defaults    0 0（2）创建挂载点    mkdir /mnt/cdrom（3）刷新挂载表    mount -a（4）查看    lsblk （5）编辑仓库文件    vim /etc/yum.repo.d/a.repo内容：    [a]    name=a    gpgcheck=0    enabled=1    baseurl=file:///mnt/cdrom（6）查看仓库资源    yum repolist</code></pre><h3 id="三、安装软件包"><a href="#三、安装软件包" class="headerlink" title="三、安装软件包"></a>三、安装软件包</h3><pre><code>    yum install -y bind*</code></pre><h3 id="四、编辑主配置文件"><a href="#四、编辑主配置文件" class="headerlink" title="四、编辑主配置文件"></a>四、编辑主配置文件</h3><pre><code>    vim /etc/named.conf内容：    options &#123;    listen-on port 53 &#123; 192.168.35.1; &#125;;            //监听端口53，后面接本机Ip    listen-on-v6 port 53 &#123; ::1; &#125;;    directory       &quot;/var/named&quot;;    dump-file       &quot;/var/named/data/cache_dump.db&quot;;    statistics-file &quot;/var/named/data/named_stats.txt&quot;;    memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;;    allow-query     &#123; any; &#125;;                    //所有人可访问    &#125;;    zone &quot;.&quot; IN &#123;            type hint;            file &quot;named.ca&quot;;    &#125;;    zone &quot;zlf.com&quot;IN &#123;                             //正向解析域             type master;            file &quot;zlf.com.zone&quot;;                //正向解析文件    &#125;;    zone &quot;35.168.192.in-addr.arpa&quot; IN &#123;            /反向解析域             type master;            file &quot;zlffx.com.zone&quot;;                //反向解析文件    &#125;;</code></pre><h3 id="五、创建正向解析文件"><a href="#五、创建正向解析文件" class="headerlink" title="五、创建正向解析文件"></a>五、创建正向解析文件</h3><pre><code>（1）切换到解析文件存放目录下cd /var/named/（2）复制模板文件作为解析文件cp named.locahost zlf.com.zone            //复制为模板文件作为正向解析文件vim /var/named/zlf.com.zone                //编辑正向解析文件内容：    TL 1D    @       IN SOA  @ www.zlf.com. (                                            0       ; serial                                            1D      ; refresh                                            1H      ; retry                                            1W      ; expire                                            3H )    ; minimum            NS      www.zlf.com.    www     A       192.168.35.1    ftp     A       192.168.35.2</code></pre><h3 id="六、创建反向解析文件"><a href="#六、创建反向解析文件" class="headerlink" title="六、创建反向解析文件"></a>六、创建反向解析文件</h3><pre><code>cd /var/named/cp named.localhost  zlffx.com.zonevim /var/named/zlffx.com.zone内容：$TTL 1D@       IN SOA  @ www.zlf.com. (                                        0       ; serial                                        1D      ; refresh                                        1H      ; retry                                        1W      ; expire                                        3H )    ; minimum        NS      www.zlf.com.1       PTR     www.zlf.com.2       PTR     ftp.zlf.com.</code></pre><h3 id="七、重启服务"><a href="#七、重启服务" class="headerlink" title="七、重启服务"></a>七、重启服务</h3><pre><code>systemctl restart named</code></pre><h3 id="八、测试"><a href="#八、测试" class="headerlink" title="八、测试"></a>八、测试</h3><pre><code>nslookup&gt;www.zlf.com&gt;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>linux/server</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/08/22/hello-world/"/>
    <url>/2020/08/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
